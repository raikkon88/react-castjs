{"version":3,"sources":["../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/Cast.js","../../src/CastProvider/index.js","../../src/index.js","../../src/CastButton/index.js","CastExample.js","App.js","index.js","../../dist/chromecast~bhycLeeK.svg"],"names":["Symbol","iterator","asyncIterator","_catch","body","recover","result","e","then","timer","Promise","setTimeout","resolve","Cast","Castjs","opt","this","_init","cast","CastContext","RemotePlayer","RemotePlayerController","CastState","CastContextEventType","joinpolicies","chrome","receiverApplicationId","autoJoinPolicy","language","resumeSavedSession","window","script","document","Error","_isAvailableChanged","_isMediaLoadedChanged","_player","Number","Math","label","src","trackContentId","active","_isConnectedChanged","_currentTimeChanged","past","_controller","getSeekPosition","getFormattedTime","_durationChanged","_volumeLevelChanged","_isMutedChanged","old","muted","_isPausedChanged","_playerStateChanged","playerState","on","_events","off","fn","func","trigger","tail","Array","event","metadata","_load","mediaInfo","tracks","track","parseInt","request","error","seek","seconds","getSeekTime","volume","play","pause","mute","unmute","subtitle","i","disconnect","useProvideCast","chromecast","useState","createContext","useCast","useContext","CastProvider","children","context","value","_useCast","CastButton","props","castAvailable","setCastAvailable","size","style","title","onClick","console","useEffect","className","_styles","disabled","width","height","marginLeft","fontSize","CastExample","available","connected","castConnected","setCastConnected","paused","isPlaying","setIsPlaying","source","setSource","poster","setPoster","setTitle","inputRef","useRef","inputImgRef","statusRef","_log","log","setLog","pushMessage","msg","forEach","m","current","push","date","Date","toLocaleTimeString","a","onAvailable","device","scrollTop","scrollHeight","href","target","rel","ref","type","onFocus","select","onChange","fontWeight","background","padding","position","length","map","l","key","toString","App","ReactDOM","render","getElementById","module","exports"],"mappings":"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","file":"static/js/main.8285528f.chunk.js","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","// Import cast framework\r\nfunction loadScript(){\r\n    return new Promise((resolve, reject) => {\r\n        window['__onGCastApiAvailable'] = resolve\r\n\r\n        if (window.chrome && !window.chrome.cast) {\r\n            var script = document.createElement('script')\r\n            script.src = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1'\r\n            script.onerror = reject\r\n            document.head.appendChild(script)\r\n        }\r\n    })\r\n}\r\n\r\nconst timer = new Promise((resolve, reject) => {\r\n    setTimeout(resolve, 5000)\r\n})\r\n\r\n// Castjs\r\nclass Castjs {\r\n    // constructor takes optional options\r\n    constructor(opt = {}) {\r\n        \r\n        // set default receiver ID if none provided\r\n        if (!opt.receiver || opt.receiver === '') {\r\n            opt.receiver = 'CC1AD845'\r\n        }\r\n\r\n        // private variables\r\n        this._events     = {}\r\n        this._player     = null\r\n        this._controller = null\r\n        this._mediaSession = null\r\n\r\n        // public variables\r\n        this.version        = 'v4.1.2'\r\n        this.receiver       = opt.receiver\r\n        this.joinpolicy     = opt.joinpolicy\r\n        this.available      = false\r\n        this.connected      = false\r\n        this.device         = 'Chromecast'\r\n        this.src            = ''\r\n        this.title          = ''\r\n        this.description    = ''\r\n        this.poster         = ''\r\n        this.subtitles      = []\r\n        this.volumeLevel    = 1\r\n        this.muted          = false\r\n        this.paused         = false\r\n        this.time           = 0\r\n        this.timePretty     = '00:00:00'\r\n        this.duration       = 0\r\n        this.durationPretty = '00:00:00'\r\n        this.progress       = 0\r\n        this.state          = 'disconnected'\r\n        // initialize chromecast framework\r\n        this._init()\r\n    }\r\n    \r\n    async _init() {\r\n        // casting only works on chrome, opera, brave and vivaldi\r\n        if (!window.chrome || !window.chrome.cast || !window.chrome.cast.isAvailable) {\r\n            try {\r\n                await Promise.race([loadScript(), timer])\r\n                if (!window.chrome || !window.chrome.cast || !window.chrome.cast.isAvailable){\r\n                    return this.trigger('error', 'Not available in this browser')\r\n                }\r\n            } catch (error) {\r\n                this.trigger('error', error)\r\n                throw new Error(\"Error loading Cast API\")\r\n            }\r\n        }\r\n\r\n        const { CastContext = null, RemotePlayer, RemotePlayerController, CastState, CastContextEventType } = cast.framework\r\n\r\n        // valid join policies\r\n        const joinpolicies = [\r\n            chrome.cast.AutoJoinPolicy.TAB_AND_ORIGIN_SCOPED,\r\n            chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,\r\n            chrome.cast.AutoJoinPolicy.PAGE_SCOPED\r\n        ]\r\n\r\n        // only allow valid join policy\r\n        if (!this.joinpolicies || joinpolicies.indexOf(this.joinpolicy) === -1) {\r\n            this.joinpolicy = chrome.cast.AutoJoinPolicy.TAB_AND_ORIGIN_SCOPED\r\n        }\r\n\r\n\r\n        // initialize cast API\r\n        CastContext.getInstance().setOptions({\r\n            receiverApplicationId:      this.receiver,\r\n            autoJoinPolicy:             this.joinpolicy,\r\n            language:                   'en-US',\r\n            resumeSavedSession:         false,\r\n        })\r\n        // create remote player controller\r\n        this._player = new RemotePlayer()\r\n        this._controller = new RemotePlayerController(this._player)\r\n\r\n        // register callback events\r\n        this._controller.addEventListener('isConnectedChanged',  this._isConnectedChanged.bind(this))\r\n        this._controller.addEventListener('isMediaLoadedChanged',this._isMediaLoadedChanged.bind(this))\r\n        this._controller.addEventListener('isMutedChanged',      this._isMutedChanged.bind(this))\r\n        this._controller.addEventListener('isPausedChanged',     this._isPausedChanged.bind(this))\r\n        this._controller.addEventListener('currentTimeChanged',  this._currentTimeChanged.bind(this))\r\n        this._controller.addEventListener('durationChanged',     this._durationChanged.bind(this))\r\n        this._controller.addEventListener('volumeLevelChanged',  this._volumeLevelChanged.bind(this))\r\n        this._controller.addEventListener('playerStateChanged',  this._playerStateChanged.bind(this))\r\n\r\n        CastContext.getInstance().addEventListener(CastContextEventType.CAST_STATE_CHANGED, this._isAvailableChanged.bind(this))\r\n        this.available = CastContext.getInstance().getCastState() !== CastState.NO_DEVICES_AVAILABLE\r\n        this.trigger('available')\r\n    }\r\n\r\n    _isAvailableChanged(e) {\r\n        const { CastContext, CastState } = cast.framework \r\n        this.available = CastContext.getInstance().getCastState() !== CastState.NO_DEVICES_AVAILABLE\r\n        this.trigger('available')\r\n    }\r\n\r\n    _isMediaLoadedChanged() {\r\n        // don't update media info if not available\r\n        if (!this._player.isMediaLoaded) {\r\n            return\r\n        }\r\n        // there is a bug where mediaInfo is not directly available\r\n        // so we are skipping one tick in the event loop, zzzzzzzzz\r\n        setTimeout(() => {\r\n            if (!this._player.mediaInfo) {\r\n                return\r\n            }\r\n            // Update device name\r\n            this.device = cast.framework.CastContext.getInstance().getCurrentSession().getCastDevice().friendlyName || this.device\r\n\r\n            // Update media variables\r\n            this.src                = this._player.mediaInfo.contentId\r\n            this.title              = this._player.title || null\r\n            this.description        = this._player.mediaInfo.metadata.subtitle || null\r\n            this.poster             = this._player.imageUrl || null\r\n            this.subtitles          = []\r\n            this.volumeLevel        = this.volumeLevel = Number((this._player.volumeLevel).toFixed(1))\r\n            this.muted              = this._player.isMuted\r\n            this.paused             = this._player.isPaused\r\n            this.time               = Math.round(this._player.currentTime, 1)\r\n            this.timePretty         = this._controller.getFormattedTime(this.time)\r\n            this.duration           = this._player.duration\r\n            this.durationPretty     = this._controller.getFormattedTime(this._player.duration)\r\n            this.progress           = this._controller.getSeekPosition(this.time, this._player.duration)\r\n            this.state              = this._player.playerState.toLowerCase()\r\n\r\n            // Loop over the subtitle tracks\r\n            for (var i in this._player.mediaInfo.tracks) {\r\n                // Check for subtitle\r\n                if (this._player.mediaInfo.tracks[i].type === 'TEXT') {\r\n                    // Push to media subtitles array\r\n                    this.subtitles.push({\r\n                        label: this._player.mediaInfo.tracks[i].name,\r\n                        src:   this._player.mediaInfo.tracks[i].trackContentId\r\n                    })\r\n                }\r\n            }\r\n            // Get the active subtitle\r\n            var active = cast.framework.CastContext.getInstance().getCurrentSession().getSessionObj().media[0].activeTrackIds\r\n            if (active && active.length && this.subtitles[active[0]]) {\r\n                this.subtitles[active[0]].active = true\r\n            }\r\n        })\r\n\r\n    }\r\n    // Player controller events\r\n    _isConnectedChanged() {\r\n        this.connected = this._player.isConnected\r\n        if (this.connected) {\r\n            this.device = cast.framework.CastContext.getInstance().getCurrentSession().getCastDevice().friendlyName || this.device\r\n        }\r\n        this.state = !this.connected ? 'disconnected' : 'connected'\r\n        this.trigger('statechange')\r\n        this.trigger(!this.connected ? 'disconnect' : 'connect')\r\n    }\r\n    _currentTimeChanged() {\r\n        var past            = this.time\r\n        this.time           = Math.round(this._player.currentTime, 1)\r\n        this.duration       = this._player.duration\r\n        this.progress       = this._controller.getSeekPosition(this.time, this.duration)\r\n        this.timePretty     = this._controller.getFormattedTime(this.time)\r\n        this.durationPretty = this._controller.getFormattedTime(this.duration)\r\n        // Only trigger timeupdate if there is a difference\r\n        if (past != this.time && !this._player.isPaused) {\r\n            this.trigger('timeupdate')\r\n        }\r\n    }\r\n    _durationChanged() {\r\n        this.duration = this._player.duration\r\n    }\r\n    _volumeLevelChanged() {\r\n        this.volumeLevel = Number((this._player.volumeLevel).toFixed(1))\r\n        if (this._player.isMediaLoaded) {\r\n            this.trigger('volumechange')\r\n        }\r\n    }\r\n    _isMutedChanged() {\r\n        var old = this.muted\r\n        this.muted = this._player.isMuted\r\n        if (old != this.muted) {\r\n            this.trigger(this.muted ? 'mute' : 'unmute')\r\n        }\r\n    }\r\n    _isPausedChanged() {\r\n        this.paused = this._player.isPaused\r\n        if (this.paused) {\r\n            this.trigger('pause')\r\n        }\r\n    }\r\n    _playerStateChanged() {\r\n        this.connected = this._player.isConnected\r\n        if (!this.connected) {\r\n            return\r\n        }\r\n        this.device = cast.framework.CastContext.getInstance().getCurrentSession().getCastDevice().friendlyName || this.device\r\n        this.state = this._player.playerState.toLowerCase()\r\n        switch(this.state) {\r\n            case 'idle':\r\n                this.trigger('statechange')\r\n                const idleReason = this._mediaSession?.idleReason ?? \"\"\r\n                // don't trigger end if cast was interrupted. new media was loaded\r\n                if(idleReason !== chrome.cast.media.IdleReason.INTERRUPTED){\r\n                    this.state = 'ended'\r\n                    this.trigger('end')\r\n                }\r\n                return this\r\n            case 'buffering':\r\n                this.time           = Math.round(this._player.currentTime, 1)\r\n                this.duration       = this._player.duration\r\n                this.progress       = this._controller.getSeekPosition(this.time, this.duration)\r\n                this.timePretty     = this._controller.getFormattedTime(this.time)\r\n                this.durationPretty = this._controller.getFormattedTime(this.duration)\r\n                this.trigger('statechange')\r\n                this.trigger('buffering')\r\n                return this\r\n            case 'playing':\r\n                // we have to skip a tick to give mediaInfo some time to update\r\n                setTimeout(() => {\r\n                    this.trigger('statechange')\r\n                    this.trigger('playing')\r\n                })\r\n                return this\r\n        }\r\n    }\r\n    // Class functions\r\n    on(event, cb) {\r\n        // If event is not registered, create array to store callbacks\r\n        if (!this._events[event]) {\r\n            this._events[event] = []\r\n        }\r\n        // Push callback into event array\r\n        this._events[event].push(cb)\r\n        return this\r\n    }\r\n    off(event, fn) {\r\n        if (!event) {\r\n            // if no event name was given, reset all events\r\n            this._events = {}\r\n        } else if (this._events[event]) {\r\n            if(fn){\r\n                this._events[event].forEach((func, i) => {\r\n                    if(fn.toString() === func.toString()){\r\n                        this._events[event].splice(i,1)\r\n                    }\r\n                })\r\n            }else{\r\n                // remove all callbacks from event\r\n                this._events[event] = []\r\n            }\r\n        }\r\n        return this\r\n    }\r\n    trigger(event) {\r\n        // Slice arguments into array\r\n        var tail = Array.prototype.slice.call(arguments, 1)\r\n        // If event exist, call callback with callback data\r\n        for (var i in this._events[event]) {\r\n            this._events[event][i].apply(this, tail)\r\n        }\r\n        // dont call global event if error\r\n        if (event === 'error') {\r\n            return this\r\n        }\r\n        // call global event handler if exist\r\n        for (var i in this._events['event']) {\r\n            this._events['event'][i].apply(this, [event])\r\n        }\r\n        return this\r\n    }\r\n\r\n    async cast(src, metadata = {}) {\r\n        // We need a source! Don't forget to enable CORS\r\n        if (!src) {\r\n            return this.trigger('error', 'No media source specified.')\r\n        }\r\n\r\n        const { CastContext } = cast.framework\r\n\r\n\r\n        metadata.src = src\r\n        // Update media variables with user input\r\n        for (var key in metadata) {\r\n            if (metadata.hasOwnProperty(key)) {\r\n                this[key] = metadata[key]\r\n            }\r\n        }\r\n\r\n        \r\n        try {\r\n            if(!CastContext.getInstance().getCurrentSession()){\r\n                await CastContext.getInstance().requestSession()\r\n            }\r\n            await _load.apply(this)\r\n        } catch (error) {\r\n            if(error !== 'cancel'){\r\n                this.trigger('error', error)\r\n            }\r\n        }\r\n\r\n        async function _load(){\r\n            {\r\n                if (!CastContext.getInstance().getCurrentSession()) {\r\n                    return this.trigger('error', 'Could not connect with the cast device')\r\n                }\r\n                // Create media cast object\r\n                var mediaInfo = new chrome.cast.media.MediaInfo(this.src)\r\n                mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata()\r\n    \r\n                // This part is the reason why people love this library <3\r\n                if (this.subtitles.length) {\r\n                    // I'm using the Netflix subtitle styling\r\n                    // chrome.cast.media.TextTrackFontGenericFamily.CASUAL\r\n                    // chrome.cast.media.TextTrackEdgeType.DROP_SHADOW\r\n                    mediaInfo.textTrackStyle = new chrome.cast.media.TextTrackStyle()\r\n                    mediaInfo.textTrackStyle.backgroundColor = '#00000000'\r\n                    mediaInfo.textTrackStyle.edgeColor       = '#00000016'\r\n                    mediaInfo.textTrackStyle.edgeType        = 'DROP_SHADOW'\r\n                    mediaInfo.textTrackStyle.fontFamily      = 'CASUAL'\r\n                    mediaInfo.textTrackStyle.fontScale       = 1.0\r\n                    mediaInfo.textTrackStyle.foregroundColor = '#FFFFFF'\r\n    \r\n                    var tracks = []\r\n                    for (var i in this.subtitles) {\r\n                        // chrome.cast.media.TrackType.TEXT\r\n                        // chrome.cast.media.TextTrackType.CAPTIONS\r\n                        var track =  new chrome.cast.media.Track(i, 'TEXT')\r\n                        track.name =             this.subtitles[i].label\r\n                        track.subtype =          'CAPTIONS'\r\n                        track.trackContentId =   this.subtitles[i].src\r\n                        track.trackContentType = 'text/vtt'\r\n                        // This bug made me question life for a while\r\n                        track.trackId = parseInt(i)\r\n                        tracks.push(track)\r\n                    }\r\n                    mediaInfo.tracks = tracks\r\n                }\r\n                // Let's prepare the metadata\r\n                mediaInfo.metadata.images =   [new chrome.cast.Image(this.poster)]\r\n                mediaInfo.metadata.title =    this.title\r\n                mediaInfo.metadata.subtitle = this.description\r\n                // Prepare the actual request\r\n                var request = new chrome.cast.media.LoadRequest(mediaInfo)\r\n                // Didn't really test this currenttime thingy, dont forget\r\n                request.currentTime = this.time\r\n                request.autoplay = !this.paused\r\n                // If multiple subtitles, use the active: true one\r\n                if (this.subtitles.length) {\r\n                    for (var i in this.subtitles) {\r\n                        if (this.subtitles[i].active) {\r\n                            request.activeTrackIds = [parseInt(i)]\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n\r\n                try {\r\n                    await CastContext.getInstance().getCurrentSession().loadMedia(request)    \r\n                    this.device = CastContext.getInstance().getCurrentSession().getCastDevice().friendlyName || this.device\r\n                    this._mediaSession = CastContext.getInstance().getCurrentSession().getMediaSession()\r\n                } catch (error) {\r\n                    return this.trigger('error', error)\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    seek(seconds, isPercentage) {\r\n        // if seek(15, true) we assume 15 is percentage instead of seconds\r\n        if (isPercentage) {\r\n            seconds = this._controller.getSeekTime(seconds, this._player.duration)\r\n        }\r\n        this._player.currentTime = seconds\r\n        this._controller.seek()\r\n        return this\r\n    }\r\n    volume(float) {\r\n        this._player.volumeLevel = float\r\n        this._controller.setVolumeLevel()\r\n        return this\r\n    }\r\n    play() {\r\n        if (this.paused) {\r\n            this._controller.playOrPause()\r\n        }\r\n        return this\r\n    }\r\n    pause() {\r\n        if (!this.paused) {\r\n            this._controller.playOrPause()\r\n        }\r\n        return this\r\n    }\r\n    mute() {\r\n        if (!this.muted) {\r\n            this._controller.muteOrUnmute()\r\n        }\r\n        return this\r\n    }\r\n    unmute() {\r\n        if (this.muted) {\r\n            this._controller.muteOrUnmute()\r\n        }\r\n        return this\r\n    }\r\n    // subtitle allows you to change active subtitles while casting\r\n    subtitle(index) {\r\n        // this is my favorite part of castjs\r\n        // prepare request to edit the tracks on current session\r\n        var request = new chrome.cast.media.EditTracksInfoRequest([parseInt(index)])\r\n        cast.framework.CastContext.getInstance().getCurrentSession().getSessionObj().media[0].editTracksInfo(request, () => {\r\n            // after updating the device we should update locally\r\n            // loop trough subtitles\r\n            for (var i in this.subtitles) {\r\n                // remove active key from all subtitles\r\n                delete this.subtitles[i].active\r\n                // if subtitle matches given index, we set to true\r\n                if (i == index) {\r\n                    this.subtitles[i].active = true\r\n                }\r\n            }\r\n            return this.trigger('subtitlechange')\r\n        }, (err) => {\r\n            // catch any error\r\n            return this.trigger('error', err)\r\n        })\r\n    }\r\n    // disconnect will end the current session\r\n    disconnect() {\r\n        cast.framework.CastContext.getInstance().endCurrentSession(true)\r\n        this._controller.stop()\r\n\r\n        this._mediaSession = null\r\n\r\n        // application variables\r\n        this.connected  = false\r\n        this.device     = 'Chromecast'\r\n\r\n        // media variables\r\n        this.src         = ''\r\n        this.title       = ''\r\n        this.description = ''\r\n        this.poster      = ''\r\n        this.subtitles   = []\r\n\r\n        // player variable\r\n        this.volumeLevel    = 1\r\n        this.muted          = false\r\n        this.paused         = false\r\n        this.time           = 0\r\n        this.timePretty     = '00:00:00'\r\n        this.duration       = 0\r\n        this.durationPretty = '00:00:00'\r\n        this.progress       = 0\r\n        this.state          = 'disconnected'\r\n\r\n\r\n        this.trigger('disconnect')\r\n        return this\r\n    }\r\n}\r\n\r\nconst Cast = Castjs\r\nexport default Cast","import React from \"react\"\r\nimport { createContext, useContext, useEffect, useState } from 'react'\r\nimport Cast from \"../Cast\"\r\n\r\n\r\n\r\nconst useProvideCast = () => {\r\n    const [chromecast, setChromecast] = useState(new Cast())\r\n\r\n    return {\r\n        chromecast,\r\n    }\r\n}\r\n\r\nconst CastContext = createContext(useProvideCast)\r\n\r\nconst CastProvider = ({ children }) => {\r\n    const context = useProvideCast()\r\n    return (\r\n        <CastContext.Provider value={context}>\r\n            {children}\r\n        </CastContext.Provider>\r\n    )\r\n}\r\n\r\nexport const useCast = () => useContext(CastContext)\r\n\r\nexport default CastProvider","import React from 'react'\nimport {default as Provider, useCast as _useCast} from './CastProvider'\n\n\nimport { default as Button } from './CastButton'\n\nexport const CastProvider = Provider\n\nexport const useCast = _useCast\n\nexport const CastButton = Button","import React, { useEffect, useState } from \"react\"\r\nimport { useCast } from \"../CastProvider\"\r\n\r\nimport { default as ico } from 'chromecast.svg'\r\n\r\nimport _styles from './styles.module.css'\r\n\r\nfunction CastButton(props){\r\n\r\n    const { chromecast } = useCast()\r\n\r\n    const [castAvailable, setCastAvailable] = useState(chromecast.available)\r\n\r\n    const { size = 20, style = {}, title = null, onClick = () => { console.error(\"No handler available.\") } } = props\r\n\r\n    useEffect(() => {\r\n        chromecast.on('available', () => {\r\n            setCastAvailable(chromecast.available)\r\n        })\r\n\r\n        return function cleanup(){\r\n            chromecast.off()\r\n        }\r\n    }, [])\r\n\r\n    return (\r\n        <button onClick={onClick} style={style} className={_styles.cast_button} disabled={!castAvailable} {...props}>\r\n            <img src={ico} style={{ width: size, height: size }} />\r\n            {title\r\n            &&\r\n            <span style={{ marginLeft: \"5px\", fontSize: `${size*.55}px` }}>\r\n               {title}    \r\n            </span>}\r\n        </button>\r\n    )\r\n}\r\n\r\nexport default CastButton","import React, { useEffect, useRef, useState } from 'react'\r\nimport { useCast, CastButton } from 'react-castjs'\r\n\r\n\r\n\r\nfunction CastExample(){\r\n    // use the hook\r\n    const { chromecast } = useCast()\r\n    const [castAvailable, setCastAvailable] = useState(chromecast.available)\r\n    const [castConnected, setCastConnected] = useState(chromecast.connected)\r\n    const [isPlaying, setIsPlaying] = useState(!chromecast.paused)\r\n    const [source, setSource] = useState('https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/Sintel.mp4')\r\n    const [poster, setPoster] = useState('https://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/Sintel_poster.jpg/800px-Sintel_poster.jpg')\r\n    const [title, setTitle] = useState('Example Title')\r\n    const inputRef = useRef()\r\n    const inputImgRef = useRef()\r\n    const statusRef = useRef()\r\n\r\n    const _log = useRef([])\r\n\r\n    const [log, setLog] = useState([])\r\n\r\n    useEffect(() => {\r\n        pushMessage(['initializing cast'])\r\n\r\n        function onAvailable(){\r\n            pushMessage([\"cast available: \"+chromecast.available])\r\n            setCastAvailable(chromecast.available)\r\n        }\r\n\r\n        chromecast.on('available', onAvailable)\r\n\r\n        chromecast.on('connect', () => {\r\n            pushMessage([\"cast connected\", \"connected to: \"+chromecast.device])\r\n            setCastConnected(chromecast.connected)\r\n        })\r\n        \r\n        chromecast.on('disconnect', () => {\r\n            pushMessage([\"cast disconnected\"])\r\n            setCastConnected(chromecast.connected)\r\n        })\r\n\r\n        chromecast.on('playing', () => {\r\n            setIsPlaying(true)\r\n            pushMessage([\"media playing\"])\r\n        })\r\n\r\n        chromecast.on('pause', () => {\r\n            setIsPlaying(false)\r\n            pushMessage([\"media paused\"])\r\n        })\r\n\r\n        chromecast.on('error', (e) => {\r\n            pushMessage([\"error: \"+e])\r\n        })\r\n\r\n        // remove event listeners\r\n        return function cleanup(){\r\n            chromecast.off('connect')\r\n            chromecast.off('disconnect')\r\n            // remove specific listener\r\n            chromecast.off('available', onAvailable)\r\n            chromecast.off('pause')\r\n            chromecast.off('playing')\r\n            chromecast.off('error')\r\n        }\r\n    }, [])\r\n\r\n    function pushMessage(msg = []){\r\n        msg.forEach((m) => {\r\n            _log.current.push({\r\n                date: new Date().toLocaleTimeString(),\r\n                msg: m\r\n            })\r\n        })\r\n        setLog([..._log.current])\r\n    }\r\n\r\n    useEffect(() => {\r\n        if(statusRef.current){\r\n            statusRef.current.scrollTop = statusRef.current.scrollHeight\r\n        }\r\n    }, [log])\r\n\r\n    async function cast(){\r\n        if(chromecast.available){\r\n            try {\r\n                // start casting or cast new media in the same session\r\n                await chromecast.cast(source, {\r\n                    poster     : poster,\r\n                    title      : title,\r\n                })\r\n                pushMessage([\"now casting \"+source])\r\n            } catch (error) {\r\n                console.log(error)\r\n            }\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            <h1>react-castjs demo</h1>\r\n            <div className=\"links\">\r\n                <a href=\"https://github.com/smm76/react-castjs\" target=\"_blank\" rel=\"noopener\">view on github</a>\r\n                <a href=\"https://www.npmjs.com/package/react-castjs\" target=\"_blank\" rel=\"noopener\">view on npm</a>\r\n            </div>\r\n            <div className=\"content\">\r\n                <div>\r\n\r\n                    <code>\r\n                        npm i react-castjs -S\r\n                    </code>\r\n\r\n                    <h3>Test casting</h3>\r\n                    <div>\r\n                        <label>paste source url (video, audio, image)</label>\r\n                        <input ref={ref => inputRef.current = ref} type=\"text\" value={source} onFocus={() => inputRef.current.select()} onChange={e => setSource(e.target.value)}/> \r\n                        <br/>\r\n                    </div>\r\n                    <div>\r\n                        <label>set poster image</label>\r\n                        <input ref={ref => inputImgRef.current = ref} type=\"text\" value={poster}  onFocus={() => inputImgRef.current.select()} onChange={e => setPoster(e.target.value)}/> \r\n                        <br/>\r\n                    </div>\r\n                    <div>\r\n                        <label>set title</label>\r\n                        <input type=\"text\" value={title}  onChange={e => setTitle(e.target.value)}/> \r\n                    </div>\r\n                    <br/>\r\n\r\n                    <CastButton onClick={cast} size={30} style={{ fontWeight: \"bold\", background: \"#23f17e\", padding: \".5rem\" }} title={castConnected? \"cast\" : \"start casting\"} disabled={!castAvailable || source === \"\"} />\r\n                </div>\r\n                <div>\r\n                    <div style={{ position: \"relative\" }}>\r\n                    {log.length > 0 && <button className=\"clear\" onClick={() => {\r\n                        _log.current = []\r\n                        setLog([..._log.current])\r\n                    }}>clear</button>}\r\n                    <div ref={ref => statusRef.current = ref} className=\"status\">\r\n                        {log.map((l,i) => (\r\n                            <div key={i.toString()}>\r\n                                <small style={{fontSize: \".7rem\"}}>[{l.date}]</small> {l.msg}\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                {castConnected\r\n                &&\r\n                <div className=\"controls\">\r\n                    {isPlaying\r\n                    ?\r\n                    <button onClick={() => chromecast.pause()}>\r\n                        pause\r\n                    </button>\r\n                    :\r\n                    <button onClick={() => chromecast.play()}>\r\n                        play\r\n                    </button>\r\n                    }    \r\n                    <button onClick={() => chromecast.disconnect()} style={{ marginLeft: \".5rem\" }}>\r\n                        disconnect\r\n                    </button>    \r\n                </div>}\r\n                </div>\r\n            </div>\r\n            \r\n            \r\n        </div>\r\n    )\r\n}\r\n\r\nexport default CastExample","import React, { useEffect } from 'react'\n\nimport { CastProvider } from 'react-castjs'\nimport 'react-castjs/dist/index.css'\nimport CastExample from './CastExample'\n\n\n\nconst App = () => {\n\n  return (\n    <CastProvider>\n      <div className=\"app\">\n        <CastExample />\n      </div>\n    </CastProvider>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n","module.exports = __webpack_public_path__ + \"static/media/chromecast~bhycLeeK.4a5ab6bd.svg\";"],"sourceRoot":""}