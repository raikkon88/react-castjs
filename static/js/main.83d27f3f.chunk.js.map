{"version":3,"sources":["../../dist/chromecast~bhycLeeK.svg","../../src/Cast.js","../../src/CastProvider/index.js","../../src/index.js","../../src/CastButton/index.js","CastExample.js","App.js","index.js"],"names":["module","exports","Cast","constructor","opt","this","_init","window","Promise","script","document","console","Error","cast","CastContext","CastContextEventType","joinpolicies","chrome","receiverApplicationId","autoJoinPolicy","language","resumeSavedSession","RemotePlayerController","_isConnectedChanged","bind","_isMediaLoadedChanged","_isMutedChanged","_isPausedChanged","_currentTimeChanged","_durationChanged","_volumeLevelChanged","_playerStateChanged","_isAvailableChanged","CastState","_player","setTimeout","Number","Math","label","src","trackContentId","active","past","_controller","getSeekPosition","getFormattedTime","old","muted","playerState","on","_events","off","fn","func","trigger","tail","Array","event","a","mediaInfo","subtitles","tracks","track","i","parseInt","request","metadata","_load","error","seek","seconds","getSeekTime","volume","play","pause","mute","unmute","subtitle","err","disconnect","useProvideCast","useState","chromecast","createContext","useCast","useContext","CastProvider","children","context","value","_useCast","CastButton","props","size","style","title","onClick","useEffect","setCastAvailable","_styles","castAvailable","width","height","marginLeft","fontSize","CastExample","available","connected","castConnected","setCastConnected","paused","isPlaying","setIsPlaying","source","setSource","poster","setPoster","setTitle","inputRef","useRef","inputImgRef","statusRef","_log","log","setLog","pushMessage","msg","forEach","m","current","push","date","Date","toLocaleTimeString","onAvailable","device","scrollTop","scrollHeight","className","href","target","rel","ref","type","onFocus","select","onChange","e","fontWeight","background","padding","disabled","position","length","map","l","key","toString","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.83d27f3f.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/chromecast~bhycLeeK.4a5ab6bd.svg\";","// Import cast framework\r\nfunction loadScript(){\r\n    return new Promise((resolve, reject) => {\r\n        window['__onGCastApiAvailable'] = resolve\r\n\r\n        if (window.chrome && !window.chrome.cast) {\r\n            var script = document.createElement('script')\r\n            script.src = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1'\r\n            script.onerror = reject\r\n            document.head.appendChild(script)\r\n        }\r\n    })\r\n}\r\n\r\n// Castjs\r\nclass Castjs {\r\n    // constructor takes optional options\r\n    constructor(opt = {}) {\r\n        \r\n        // set default receiver ID if none provided\r\n        if (!opt.receiver || opt.receiver === '') {\r\n            opt.receiver = 'CC1AD845'\r\n        }\r\n\r\n        // private variables\r\n        this._events     = {}\r\n        this._player     = null\r\n        this._controller = null\r\n        this._mediaSession = null\r\n\r\n        // public variables\r\n        this.version        = 'v4.1.2'\r\n        this.receiver       = opt.receiver\r\n        this.joinpolicy     = opt.joinpolicy\r\n        this.available      = false\r\n        this.connected      = false\r\n        this.device         = 'Chromecast'\r\n        this.src            = ''\r\n        this.title          = ''\r\n        this.description    = ''\r\n        this.poster         = ''\r\n        this.subtitles      = []\r\n        this.volumeLevel    = 1\r\n        this.muted          = false\r\n        this.paused         = false\r\n        this.time           = 0\r\n        this.timePretty     = '00:00:00'\r\n        this.duration       = 0\r\n        this.durationPretty = '00:00:00'\r\n        this.progress       = 0\r\n        this.state          = 'disconnected'\r\n\r\n        // initialize chromecast framework\r\n        this._init()\r\n    }\r\n    \r\n    async _init() {\r\n        // casting only works on chrome, opera, brave and vivaldi\r\n        if (!window.chrome || !window.chrome.cast || !window.chrome.cast.isAvailable) {\r\n            \r\n            try {\r\n                await loadScript()\r\n            } catch (error) {\r\n                this.trigger('error', error)\r\n                console.error(error)\r\n                throw new Error(\"Error loading Cast API\")\r\n            }\r\n        }\r\n\r\n        const { CastContext = null, RemotePlayer, RemotePlayerController, CastState, CastContextEventType } = cast.framework\r\n\r\n        // valid join policies\r\n        const joinpolicies = [\r\n            chrome.cast.AutoJoinPolicy.TAB_AND_ORIGIN_SCOPED,\r\n            chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,\r\n            chrome.cast.AutoJoinPolicy.PAGE_SCOPED\r\n        ]\r\n\r\n        // only allow valid join policy\r\n        if (!this.joinpolicies || joinpolicies.indexOf(this.joinpolicy) === -1) {\r\n            this.joinpolicy = chrome.cast.AutoJoinPolicy.TAB_AND_ORIGIN_SCOPED\r\n        }\r\n\r\n\r\n        // initialize cast API\r\n        CastContext.getInstance().setOptions({\r\n            receiverApplicationId:      this.receiver,\r\n            autoJoinPolicy:             this.joinpolicy,\r\n            language:                   'en-US',\r\n            resumeSavedSession:         false,\r\n        })\r\n        // create remote player controller\r\n        this._player = new RemotePlayer()\r\n        this._controller = new RemotePlayerController(this._player)\r\n\r\n        // register callback events\r\n        this._controller.addEventListener('isConnectedChanged',  this._isConnectedChanged.bind(this))\r\n        this._controller.addEventListener('isMediaLoadedChanged',this._isMediaLoadedChanged.bind(this))\r\n        this._controller.addEventListener('isMutedChanged',      this._isMutedChanged.bind(this))\r\n        this._controller.addEventListener('isPausedChanged',     this._isPausedChanged.bind(this))\r\n        this._controller.addEventListener('currentTimeChanged',  this._currentTimeChanged.bind(this))\r\n        this._controller.addEventListener('durationChanged',     this._durationChanged.bind(this))\r\n        this._controller.addEventListener('volumeLevelChanged',  this._volumeLevelChanged.bind(this))\r\n        this._controller.addEventListener('playerStateChanged',  this._playerStateChanged.bind(this))\r\n\r\n        CastContext.getInstance().addEventListener(CastContextEventType.CAST_STATE_CHANGED, this._isAvailableChanged.bind(this))\r\n        this.available = CastContext.getInstance().getCastState() !== CastState.NO_DEVICES_AVAILABLE\r\n        this.trigger('available')\r\n    }\r\n\r\n    _isAvailableChanged(e) {\r\n        const { CastContext, CastState } = cast.framework \r\n        this.available = CastContext.getInstance().getCastState() !== CastState.NO_DEVICES_AVAILABLE\r\n        this.trigger('available')\r\n    }\r\n\r\n    _isMediaLoadedChanged() {\r\n        // don't update media info if not available\r\n        if (!this._player.isMediaLoaded) {\r\n            return\r\n        }\r\n        // there is a bug where mediaInfo is not directly available\r\n        // so we are skipping one tick in the event loop, zzzzzzzzz\r\n        setTimeout(() => {\r\n            if (!this._player.mediaInfo) {\r\n                return\r\n            }\r\n            // Update device name\r\n            this.device = cast.framework.CastContext.getInstance().getCurrentSession().getCastDevice().friendlyName || this.device\r\n\r\n            // Update media variables\r\n            this.src                = this._player.mediaInfo.contentId\r\n            this.title              = this._player.title || null\r\n            this.description        = this._player.mediaInfo.metadata.subtitle || null\r\n            this.poster             = this._player.imageUrl || null\r\n            this.subtitles          = []\r\n            this.volumeLevel        = this.volumeLevel = Number((this._player.volumeLevel).toFixed(1))\r\n            this.muted              = this._player.isMuted\r\n            this.paused             = this._player.isPaused\r\n            this.time               = Math.round(this._player.currentTime, 1)\r\n            this.timePretty         = this._controller.getFormattedTime(this.time)\r\n            this.duration           = this._player.duration\r\n            this.durationPretty     = this._controller.getFormattedTime(this._player.duration)\r\n            this.progress           = this._controller.getSeekPosition(this.time, this._player.duration)\r\n            this.state              = this._player.playerState.toLowerCase()\r\n\r\n            // Loop over the subtitle tracks\r\n            for (var i in this._player.mediaInfo.tracks) {\r\n                // Check for subtitle\r\n                if (this._player.mediaInfo.tracks[i].type === 'TEXT') {\r\n                    // Push to media subtitles array\r\n                    this.subtitles.push({\r\n                        label: this._player.mediaInfo.tracks[i].name,\r\n                        src:   this._player.mediaInfo.tracks[i].trackContentId\r\n                    })\r\n                }\r\n            }\r\n            // Get the active subtitle\r\n            var active = cast.framework.CastContext.getInstance().getCurrentSession().getSessionObj().media[0].activeTrackIds\r\n            if (active && active.length && this.subtitles[active[0]]) {\r\n                this.subtitles[active[0]].active = true\r\n            }\r\n        })\r\n\r\n    }\r\n    // Player controller events\r\n    _isConnectedChanged() {\r\n        this.connected = this._player.isConnected\r\n        if (this.connected) {\r\n            this.device = cast.framework.CastContext.getInstance().getCurrentSession().getCastDevice().friendlyName || this.device\r\n        }\r\n        this.state = !this.connected ? 'disconnected' : 'connected'\r\n        this.trigger('statechange')\r\n        this.trigger(!this.connected ? 'disconnect' : 'connect')\r\n    }\r\n    _currentTimeChanged() {\r\n        var past            = this.time\r\n        this.time           = Math.round(this._player.currentTime, 1)\r\n        this.duration       = this._player.duration\r\n        this.progress       = this._controller.getSeekPosition(this.time, this.duration)\r\n        this.timePretty     = this._controller.getFormattedTime(this.time)\r\n        this.durationPretty = this._controller.getFormattedTime(this.duration)\r\n        // Only trigger timeupdate if there is a difference\r\n        if (past != this.time && !this._player.isPaused) {\r\n            this.trigger('timeupdate')\r\n        }\r\n    }\r\n    _durationChanged() {\r\n        this.duration = this._player.duration\r\n    }\r\n    _volumeLevelChanged() {\r\n        this.volumeLevel = Number((this._player.volumeLevel).toFixed(1))\r\n        if (this._player.isMediaLoaded) {\r\n            this.trigger('volumechange')\r\n        }\r\n    }\r\n    _isMutedChanged() {\r\n        var old = this.muted\r\n        this.muted = this._player.isMuted\r\n        if (old != this.muted) {\r\n            this.trigger(this.muted ? 'mute' : 'unmute')\r\n        }\r\n    }\r\n    _isPausedChanged() {\r\n        this.paused = this._player.isPaused\r\n        if (this.paused) {\r\n            this.trigger('pause')\r\n        }\r\n    }\r\n    _playerStateChanged() {\r\n        this.connected = this._player.isConnected\r\n        if (!this.connected) {\r\n            return\r\n        }\r\n        this.device = cast.framework.CastContext.getInstance().getCurrentSession().getCastDevice().friendlyName || this.device\r\n        this.state = this._player.playerState.toLowerCase()\r\n        switch(this.state) {\r\n            case 'idle':\r\n                this.trigger('statechange')\r\n                const idleReason = this._mediaSession?.idleReason ?? \"\"\r\n                // don't trigger end if cast was interrupted. new media was loaded\r\n                if(idleReason !== chrome.cast.media.IdleReason.INTERRUPTED){\r\n                    this.state = 'ended'\r\n                    this.trigger('end')\r\n                }\r\n                return this\r\n            case 'buffering':\r\n                this.time           = Math.round(this._player.currentTime, 1)\r\n                this.duration       = this._player.duration\r\n                this.progress       = this._controller.getSeekPosition(this.time, this.duration)\r\n                this.timePretty     = this._controller.getFormattedTime(this.time)\r\n                this.durationPretty = this._controller.getFormattedTime(this.duration)\r\n                this.trigger('statechange')\r\n                this.trigger('buffering')\r\n                return this\r\n            case 'playing':\r\n                // we have to skip a tick to give mediaInfo some time to update\r\n                setTimeout(() => {\r\n                    this.trigger('statechange')\r\n                    this.trigger('playing')\r\n                })\r\n                return this\r\n        }\r\n    }\r\n    // Class functions\r\n    on(event, cb) {\r\n        // If event is not registered, create array to store callbacks\r\n        if (!this._events[event]) {\r\n            this._events[event] = []\r\n        }\r\n        // Push callback into event array\r\n        this._events[event].push(cb)\r\n        return this\r\n    }\r\n    off(event, fn) {\r\n        if (!event) {\r\n            // if no event name was given, reset all events\r\n            this._events = {}\r\n        } else if (this._events[event]) {\r\n            if(fn){\r\n                this._events[event].forEach((func, i) => {\r\n                    if(fn.toString() === func.toString()){\r\n                        this._events[event].splice(i,1)\r\n                    }\r\n                })\r\n            }else{\r\n                // remove all callbacks from event\r\n                this._events[event] = []\r\n            }\r\n        }\r\n        return this\r\n    }\r\n    trigger(event) {\r\n        // Slice arguments into array\r\n        var tail = Array.prototype.slice.call(arguments, 1)\r\n        // If event exist, call callback with callback data\r\n        for (var i in this._events[event]) {\r\n            this._events[event][i].apply(this, tail)\r\n        }\r\n        // dont call global event if error\r\n        if (event === 'error') {\r\n            return this\r\n        }\r\n        // call global event handler if exist\r\n        for (var i in this._events['event']) {\r\n            this._events['event'][i].apply(this, [event])\r\n        }\r\n        return this\r\n    }\r\n\r\n    async cast(src, metadata = {}) {\r\n        // We need a source! Don't forget to enable CORS\r\n        if (!src) {\r\n            return this.trigger('error', 'No media source specified.')\r\n        }\r\n\r\n        const { CastContext } = cast.framework\r\n\r\n\r\n        metadata.src = src\r\n        // Update media variables with user input\r\n        for (var key in metadata) {\r\n            if (metadata.hasOwnProperty(key)) {\r\n                this[key] = metadata[key]\r\n            }\r\n        }\r\n\r\n        \r\n        try {\r\n            if(!CastContext.getInstance().getCurrentSession()){\r\n                await CastContext.getInstance().requestSession()\r\n            }\r\n            await _load.apply(this)\r\n        } catch (error) {\r\n            if(error !== 'cancel'){\r\n                this.trigger('error', error)\r\n            }\r\n        }\r\n\r\n        async function _load(){\r\n            {\r\n                if (!CastContext.getInstance().getCurrentSession()) {\r\n                    return this.trigger('error', 'Could not connect with the cast device')\r\n                }\r\n                // Create media cast object\r\n                var mediaInfo = new chrome.cast.media.MediaInfo(this.src)\r\n                mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata()\r\n    \r\n                // This part is the reason why people love this library <3\r\n                if (this.subtitles.length) {\r\n                    // I'm using the Netflix subtitle styling\r\n                    // chrome.cast.media.TextTrackFontGenericFamily.CASUAL\r\n                    // chrome.cast.media.TextTrackEdgeType.DROP_SHADOW\r\n                    mediaInfo.textTrackStyle = new chrome.cast.media.TextTrackStyle()\r\n                    mediaInfo.textTrackStyle.backgroundColor = '#00000000'\r\n                    mediaInfo.textTrackStyle.edgeColor       = '#00000016'\r\n                    mediaInfo.textTrackStyle.edgeType        = 'DROP_SHADOW'\r\n                    mediaInfo.textTrackStyle.fontFamily      = 'CASUAL'\r\n                    mediaInfo.textTrackStyle.fontScale       = 1.0\r\n                    mediaInfo.textTrackStyle.foregroundColor = '#FFFFFF'\r\n    \r\n                    var tracks = []\r\n                    for (var i in this.subtitles) {\r\n                        // chrome.cast.media.TrackType.TEXT\r\n                        // chrome.cast.media.TextTrackType.CAPTIONS\r\n                        var track =  new chrome.cast.media.Track(i, 'TEXT')\r\n                        track.name =             this.subtitles[i].label\r\n                        track.subtype =          'CAPTIONS'\r\n                        track.trackContentId =   this.subtitles[i].src\r\n                        track.trackContentType = 'text/vtt'\r\n                        // This bug made me question life for a while\r\n                        track.trackId = parseInt(i)\r\n                        tracks.push(track)\r\n                    }\r\n                    mediaInfo.tracks = tracks\r\n                }\r\n                // Let's prepare the metadata\r\n                mediaInfo.metadata.images =   [new chrome.cast.Image(this.poster)]\r\n                mediaInfo.metadata.title =    this.title\r\n                mediaInfo.metadata.subtitle = this.description\r\n                // Prepare the actual request\r\n                var request = new chrome.cast.media.LoadRequest(mediaInfo)\r\n                // Didn't really test this currenttime thingy, dont forget\r\n                request.currentTime = this.time\r\n                request.autoplay = !this.paused\r\n                // If multiple subtitles, use the active: true one\r\n                if (this.subtitles.length) {\r\n                    for (var i in this.subtitles) {\r\n                        if (this.subtitles[i].active) {\r\n                            request.activeTrackIds = [parseInt(i)]\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n\r\n                try {\r\n                    await CastContext.getInstance().getCurrentSession().loadMedia(request)    \r\n                    this.device = CastContext.getInstance().getCurrentSession().getCastDevice().friendlyName || this.device\r\n                    this._mediaSession = CastContext.getInstance().getCurrentSession().getMediaSession()\r\n                } catch (error) {\r\n                    return this.trigger('error', error)\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    seek(seconds, isPercentage) {\r\n        // if seek(15, true) we assume 15 is percentage instead of seconds\r\n        if (isPercentage) {\r\n            seconds = this._controller.getSeekTime(seconds, this._player.duration)\r\n        }\r\n        this._player.currentTime = seconds\r\n        this._controller.seek()\r\n        return this\r\n    }\r\n    volume(float) {\r\n        this._player.volumeLevel = float\r\n        this._controller.setVolumeLevel()\r\n        return this\r\n    }\r\n    play() {\r\n        if (this.paused) {\r\n            this._controller.playOrPause()\r\n        }\r\n        return this\r\n    }\r\n    pause() {\r\n        if (!this.paused) {\r\n            this._controller.playOrPause()\r\n        }\r\n        return this\r\n    }\r\n    mute() {\r\n        if (!this.muted) {\r\n            this._controller.muteOrUnmute()\r\n        }\r\n        return this\r\n    }\r\n    unmute() {\r\n        if (this.muted) {\r\n            this._controller.muteOrUnmute()\r\n        }\r\n        return this\r\n    }\r\n    // subtitle allows you to change active subtitles while casting\r\n    subtitle(index) {\r\n        // this is my favorite part of castjs\r\n        // prepare request to edit the tracks on current session\r\n        var request = new chrome.cast.media.EditTracksInfoRequest([parseInt(index)])\r\n        cast.framework.CastContext.getInstance().getCurrentSession().getSessionObj().media[0].editTracksInfo(request, () => {\r\n            // after updating the device we should update locally\r\n            // loop trough subtitles\r\n            for (var i in this.subtitles) {\r\n                // remove active key from all subtitles\r\n                delete this.subtitles[i].active\r\n                // if subtitle matches given index, we set to true\r\n                if (i == index) {\r\n                    this.subtitles[i].active = true\r\n                }\r\n            }\r\n            return this.trigger('subtitlechange')\r\n        }, (err) => {\r\n            // catch any error\r\n            return this.trigger('error', err)\r\n        })\r\n    }\r\n    // disconnect will end the current session\r\n    disconnect() {\r\n        cast.framework.CastContext.getInstance().endCurrentSession(true)\r\n        this._controller.stop()\r\n\r\n        this._mediaSession = null\r\n\r\n        // application variables\r\n        this.connected  = false\r\n        this.device     = 'Chromecast'\r\n\r\n        // media variables\r\n        this.src         = ''\r\n        this.title       = ''\r\n        this.description = ''\r\n        this.poster      = ''\r\n        this.subtitles   = []\r\n\r\n        // player variable\r\n        this.volumeLevel    = 1\r\n        this.muted          = false\r\n        this.paused         = false\r\n        this.time           = 0\r\n        this.timePretty     = '00:00:00'\r\n        this.duration       = 0\r\n        this.durationPretty = '00:00:00'\r\n        this.progress       = 0\r\n        this.state          = 'disconnected'\r\n\r\n\r\n        this.trigger('disconnect')\r\n        return this\r\n    }\r\n}\r\n\r\nconst Cast = Castjs\r\nexport default Cast","import React from \"react\"\r\nimport { createContext, useContext, useEffect, useState } from 'react'\r\nimport Cast from \"../Cast\"\r\n\r\n\r\n\r\nconst useProvideCast = () => {\r\n    const [chromecast, setChromecast] = useState(new Cast())\r\n\r\n    return {\r\n        chromecast,\r\n    }\r\n}\r\n\r\nconst CastContext = createContext(useProvideCast)\r\n\r\nconst CastProvider = ({ children }) => {\r\n    const context = useProvideCast()\r\n    return (\r\n        <CastContext.Provider value={context}>\r\n            {children}\r\n        </CastContext.Provider>\r\n    )\r\n}\r\n\r\nexport const useCast = () => useContext(CastContext)\r\n\r\nexport default CastProvider","import React from 'react'\nimport {default as Provider, useCast as _useCast} from './CastProvider'\n\n\nimport { default as Button } from './CastButton'\n\nexport const CastProvider = Provider\n\nexport const useCast = _useCast\n\nexport const CastButton = Button","import React, { useEffect, useState } from \"react\"\r\nimport { useCast } from \"../CastProvider\"\r\n\r\nimport { default as ico } from 'chromecast.svg'\r\n\r\nimport _styles from './styles.module.css'\r\n\r\nfunction CastButton(props){\r\n\r\n    const { chromecast } = useCast()\r\n\r\n    const [castAvailable, setCastAvailable] = useState(chromecast.available)\r\n\r\n    const { size = 20, style = {}, title = null, onClick = () => { console.error(\"No handler available.\") } } = props\r\n\r\n    useEffect(() => {\r\n        chromecast.on('available', () => {\r\n            setCastAvailable(chromecast.available)\r\n        })\r\n\r\n        return function cleanup(){\r\n            chromecast.off()\r\n        }\r\n    }, [])\r\n\r\n    return (\r\n        <button onClick={onClick} style={style} className={_styles.cast_button} disabled={!castAvailable} {...props}>\r\n            <img src={ico} style={{ width: size, height: size }} />\r\n            {title\r\n            &&\r\n            <span style={{ marginLeft: \"5px\", fontSize: `${size*.55}px` }}>\r\n               {title}    \r\n            </span>}\r\n        </button>\r\n    )\r\n}\r\n\r\nexport default CastButton","import React, { useEffect, useRef, useState } from 'react'\r\nimport { useCast, CastButton } from 'react-castjs'\r\n\r\n\r\n\r\nfunction CastExample(){\r\n    // use the hook\r\n    const { chromecast } = useCast()\r\n    const [castAvailable, setCastAvailable] = useState(chromecast.available)\r\n    const [castConnected, setCastConnected] = useState(chromecast.connected)\r\n    const [isPlaying, setIsPlaying] = useState(!chromecast.paused)\r\n    const [source, setSource] = useState('https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/Sintel.mp4')\r\n    const [poster, setPoster] = useState('https://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/Sintel_poster.jpg/800px-Sintel_poster.jpg')\r\n    const [title, setTitle] = useState('Example Title')\r\n    const inputRef = useRef()\r\n    const inputImgRef = useRef()\r\n    const statusRef = useRef()\r\n\r\n    const _log = useRef([])\r\n\r\n    const [log, setLog] = useState([])\r\n\r\n    useEffect(() => {\r\n\r\n\r\n        function onAvailable(){\r\n            pushMessage([\"cast available: \"+chromecast.available])\r\n            setCastAvailable(chromecast.available)\r\n        }\r\n\r\n        chromecast.on('available', onAvailable)\r\n\r\n        chromecast.on('connect', () => {\r\n            pushMessage([\"cast connected\", \"connected to: \"+chromecast.device])\r\n            setCastConnected(chromecast.connected)\r\n        })\r\n        \r\n        chromecast.on('disconnect', () => {\r\n            pushMessage([\"cast disconnected\"])\r\n            setCastConnected(chromecast.connected)\r\n        })\r\n        \r\n        chromecast.on('error', () => {\r\n            pushMessage([\"error occured\"])\r\n        })\r\n\r\n        chromecast.on('playing', () => {\r\n            setIsPlaying(true)\r\n            pushMessage([\"media playing\"])\r\n        })\r\n\r\n        chromecast.on('pause', () => {\r\n            setIsPlaying(false)\r\n            pushMessage([\"media paused\"])\r\n        })\r\n\r\n        // remove event listeners\r\n        return function cleanup(){\r\n            chromecast.off('connect')\r\n            chromecast.off('disconnect')\r\n            // remove specific listener\r\n            chromecast.off('available', onAvailable)\r\n            chromecast.off('pause')\r\n            chromecast.off('playing')\r\n        }\r\n    }, [])\r\n\r\n    function pushMessage(msg = []){\r\n        msg.forEach((m) => {\r\n            _log.current.push({\r\n                date: new Date().toLocaleTimeString(),\r\n                msg: m\r\n            })\r\n        })\r\n        setLog([..._log.current])\r\n    }\r\n\r\n    useEffect(() => {\r\n        if(statusRef.current){\r\n            statusRef.current.scrollTop = statusRef.current.scrollHeight\r\n        }\r\n    }, [log])\r\n\r\n    async function cast(){\r\n        if(chromecast.available){\r\n            try {\r\n                // start casting or cast new media in the same session\r\n                await chromecast.cast(source, {\r\n                    poster     : poster,\r\n                    title      : title,\r\n                })\r\n                pushMessage([\"now casting \"+source])\r\n            } catch (error) {\r\n                console.log(error)\r\n            }\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            <h1>react-castjs demo</h1>\r\n            <div className=\"links\">\r\n                <a href=\"https://github.com/smm76/react-castjs\" target=\"_blank\" rel=\"noopener\">view on github</a>\r\n                <a href=\"https://www.npmjs.com/package/react-castjs\" target=\"_blank\" rel=\"noopener\">view on npm</a>\r\n            </div>\r\n            <code>\r\n                npm i react-castjs -S\r\n            </code>\r\n\r\n            <h3>Test casting</h3>\r\n            <div>\r\n                <label>paste source url (video, audio, image)</label>\r\n                <input ref={ref => inputRef.current = ref} type=\"text\" value={source} style={{width: \"80%\"}} onFocus={() => inputRef.current.select()} onChange={e => setSource(e.target.value)}/> \r\n                <br/>\r\n            </div>\r\n            <div>\r\n                <label>set poster image</label>\r\n                <input ref={ref => inputImgRef.current = ref} type=\"text\" value={poster} style={{width: \"80%\"}} onFocus={() => inputImgRef.current.select()} onChange={e => setPoster(e.target.value)}/> \r\n                <br/>\r\n            </div>\r\n            <div>\r\n                <label>set title</label>\r\n                <input type=\"text\" value={title} style={{width: \"80%\"}} onChange={e => setTitle(e.target.value)}/> \r\n            </div>\r\n            <br/>\r\n\r\n            <CastButton onClick={cast} size={30} style={{ fontWeight: \"bold\", background: \"#23f17e\", padding: \".5rem\" }} title={castConnected? \"cast\" : \"start casting\"} disabled={!castAvailable || source === \"\"} />\r\n            <div style={{ position: \"relative\" }}>\r\n                {log.length > 0 && <button className=\"clear\" onClick={() => {\r\n                    _log.current = []\r\n                    setLog([..._log.current])\r\n                }}>clear</button>}\r\n                <div ref={ref => statusRef.current = ref} className=\"status\">\r\n                    {log.map((l,i) => (\r\n                        <div key={i.toString()}>\r\n                            <small style={{fontSize: \".7rem\"}}>[{l.date}]</small> {l.msg}\r\n                        </div>\r\n                    ))}\r\n                </div>\r\n            </div>\r\n            {castConnected\r\n            &&\r\n            <div className=\"controls\">\r\n                {isPlaying\r\n                ?\r\n                <button onClick={() => chromecast.pause()}>\r\n                    pause\r\n                </button>\r\n                :\r\n                <button onClick={() => chromecast.play()}>\r\n                    play\r\n                </button>\r\n                }    \r\n                <button onClick={() => chromecast.disconnect()} style={{ marginLeft: \".5rem\" }}>\r\n                    disconnect\r\n                </button>    \r\n            </div>}\r\n            \r\n        </div>\r\n    )\r\n}\r\n\r\nexport default CastExample","import React, { useEffect } from 'react'\n\nimport { CastProvider } from 'react-castjs'\nimport 'react-castjs/dist/index.css'\nimport CastExample from './CastExample'\n\n\n\nconst App = () => {\n\n  return (\n    <CastProvider>\n      <div className=\"app\">\n        <CastExample />\n      </div>\n    </CastProvider>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}