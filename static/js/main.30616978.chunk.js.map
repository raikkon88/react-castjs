{"version":3,"sources":["../../src/Cast.js","../../src/CastProvider/index.js","../../src/index.js","../../src/CastButton/index.js","Test.js","App.js","index.js","../../dist/chromecast~bhycLeeK.svg"],"names":["Cast","constructor","opt","this","_init","window","Promise","script","document","console","Error","cast","CastContext","CastContextEventType","joinpolicies","chrome","receiverApplicationId","autoJoinPolicy","language","resumeSavedSession","RemotePlayerController","_isConnectedChanged","bind","_isMediaLoadedChanged","_isMutedChanged","_isPausedChanged","_currentTimeChanged","_durationChanged","_volumeLevelChanged","_playerStateChanged","_isAvailableChanged","CastState","_player","setTimeout","Number","Math","label","src","trackContentId","active","past","_controller","getSeekPosition","getFormattedTime","old","muted","playerState","on","_events","off","trigger","tail","Array","event","a","mediaInfo","subtitles","tracks","track","i","parseInt","request","metadata","_load","error","seek","seconds","getSeekTime","volume","play","pause","mute","unmute","subtitle","err","disconnect","useProvideCast","useState","chromecast","createContext","useCast","useContext","CastProvider","children","context","value","_useCast","CastButton","props","size","styles","onClick","useEffect","setCastAvailable","style","className","_styles","disabled","castAvailable","width","height","Test","available","connected","castConnected","setCastConnected","source","setSource","inputRef","useRef","poster","title","description","log","device","ref","current","type","onFocus","select","onChange","e","target","App","href","ReactDOM","render","getElementById","module","exports"],"mappings":"wQA0dMA,E,WAzcFC,aAAsB,IAAVC,EAAU,uDAAX,GAAW,oBAGbA,EAAD,UAAJ,KAAqBA,aACjBA,uBAIJC,KAAA,WACAA,KAAA,aACAA,KAAA,iBACAA,KAAA,mBAGAA,KAAA,iBACAA,KAAA,SAAsBD,EAAtB,SACAC,KAAA,WAAsBD,EAAtB,WACAC,KAAA,aACAA,KAAA,aACAA,KAAA,oBACAA,KAAA,OACAA,KAAA,SACAA,KAAA,eACAA,KAAA,UACAA,KAAA,aACAA,KAAA,cACAA,KAAA,SACAA,KAAA,UACAA,KAAA,OACAA,KAAA,sBACAA,KAAA,WACAA,KAAA,0BACAA,KAAA,WACAA,KAAA,qBAGAA,KAAA,Q,gFAGEC,qGAEGC,OAAD,QAAmBA,cAAnB,MAA0CA,mBAA9C,YAFED,0CAtDC,IAAIE,SAAQ,cAGf,GAFAD,OAAM,sBAANA,EAEIA,gBAAkBA,cAAtB,KAA0C,CACtC,IAAIE,EAASC,uBAAb,UACAD,mFACAA,YACAC,iCA+CFJ,6DAOMD,KAAA,sBACAM,oBACM,IAAIC,MAAV,0BATNN,UAaoGO,KAAtG,UAbEP,IAaMQ,mBAbNR,MAaI,KAbJA,EAaI,EAbJA,EAaI,eAbJA,EAaI,yBAbJA,EAaI,UAAuES,EAb3ET,EAa2ES,qBAGvEC,EAAe,CACjBC,2BADiB,sBAEjBA,2BAFiB,cAGjBA,2BAHJ,aAOKZ,KAAD,eAAJ,IAA0BW,UAAqBX,KAArBW,cACtBX,KAAA,WAAkBY,2BAAlB,uBAKJH,2BAAqC,CACjCI,sBAA4Bb,KADK,SAEjCc,eAA4Bd,KAFK,WAGjCe,SAHiC,QAIjCC,oBAA4B,IAGhChB,KAAA,QAAe,IAAf,EACAA,KAAA,YAAmB,IAAIiB,EAAuBjB,KAA9C,SAGAA,KAAA,kDAAyDA,KAAKkB,oBAAoBC,KAAlFnB,OACAA,KAAA,oDAAyDA,KAAKoB,sBAAsBD,KAApFnB,OACAA,KAAA,8CAAyDA,KAAKqB,gBAAgBF,KAA9EnB,OACAA,KAAA,+CAAyDA,KAAKsB,iBAAiBH,KAA/EnB,OACAA,KAAA,kDAAyDA,KAAKuB,oBAAoBJ,KAAlFnB,OACAA,KAAA,+CAAyDA,KAAKwB,iBAAiBL,KAA/EnB,OACAA,KAAA,kDAAyDA,KAAKyB,oBAAoBN,KAAlFnB,OACAA,KAAA,kDAAyDA,KAAK0B,oBAAoBP,KAAlFnB,OAEAS,iCAA2CC,EAA3CD,mBAAoFT,KAAK2B,oBAAoBR,KAA7GV,OACAT,KAAA,UAAiBS,iCAA6CmB,EAA9D,qBACA5B,KAAA,qBAnDEC,yD,uFAsDN0B,SAAmB,GACf,MAAmCnB,KAAnC,UAAM,EAAN,EAAM,YAAeoB,EAArB,EAAqBA,UACrB5B,KAAA,UAAiBS,iCAA6CmB,EAA9D,qBACA5B,KAAA,uB,mCAGJoB,WAAwB,WAEfpB,KAAK6B,QAAV,eAKAC,YAAW,WACP,GAAK,UAAL,WAuBA,IAAK,IAAL,KAnBA,SAActB,2FAA6F,EAA3G,OAGA,MAA0B,oBAA1B,UACA,QAA0B,iBAA1B,KACA,cAA0B,uCAA1B,KACA,SAA0B,oBAA1B,KACA,eACA,cAA0B,cAAmBuB,OAAQ,UAAD,oBAApD,IACA,QAA0B,UAA1B,QACA,SAA0B,UAA1B,SACA,OAA0BC,WAAW,UAAXA,YAA1B,GACA,aAA0B,+BAAkC,EAA5D,MACA,WAA0B,UAA1B,SACA,iBAA0B,+BAAkC,UAA5D,UACA,WAA0B,8BAAiC,EAAjC,KAA4C,UAAtE,UACA,QAA0B,sBAA1B,cAGc,oBAAd,OAEI,SAAI,oCAEA,iBAAoB,CAChBC,MAAO,8BADS,KAEhBC,IAAO,8BAAiCC,iBAKpD,IAAIC,EAAS5B,sFAAb,eACI4B,GAAUA,EAAVA,QAA2B,YAAeA,EAA9C,MACI,YAAeA,EAAf,qB,iCAMZlB,WACIlB,KAAA,UAAiBA,KAAK6B,QAAtB,YACI7B,KAAJ,YACIA,KAAA,OAAcQ,2FAA6FR,KAA3G,QAEJA,KAAA,MAAcA,KAAD,UAAb,YAAa,eACbA,KAAA,uBACAA,KAAA,QAAcA,KAAD,UAAb,UAAa,gB,iCAEjBuB,WACI,IAAIc,EAAkBrC,KAAtB,KACAA,KAAA,KAAsBgC,WAAWhC,KAAK6B,QAAhBG,YAAtB,GACAhC,KAAA,SAAsBA,KAAK6B,QAA3B,SACA7B,KAAA,SAAsBA,KAAKsC,YAAYC,gBAAgBvC,KAAjC,KAA4CA,KAAlE,UACAA,KAAA,WAAsBA,KAAKsC,YAAYE,iBAAiBxC,KAAxD,MACAA,KAAA,eAAsBA,KAAKsC,YAAYE,iBAAiBxC,KAAxD,UAEIqC,GAAQrC,KAARqC,MAAsBrC,KAAK6B,QAA/B,UACI7B,KAAA,wB,8BAGRwB,WACIxB,KAAA,SAAgBA,KAAK6B,QAArB,W,iCAEJJ,WACIzB,KAAA,YAAmB+B,OAAQ/B,KAAK6B,QAAN,oBAA1B,IACI7B,KAAK6B,QAAT,eACI7B,KAAA,0B,6BAGRqB,WACI,IAAIoB,EAAMzC,KAAV,MACAA,KAAA,MAAaA,KAAK6B,QAAlB,QACIY,GAAOzC,KAAX,OACIA,KAAA,QAAaA,KAAK0C,MAAQ,OAA1B,Y,8BAGRpB,WACItB,KAAA,OAAcA,KAAK6B,QAAnB,SACI7B,KAAJ,QACIA,KAAA,mB,iCAGR0B,WAAsB,eAElB,GADA1B,KAAA,UAAiBA,KAAK6B,QAAtB,YACK7B,KAAL,UAKA,OAFAA,KAAA,OAAcQ,2FAA6FR,KAA3G,OACAA,KAAA,MAAaA,KAAK6B,QAAQc,YAA1B,cACO3C,KAAP,OACI,WAQI,OAPAA,KAAA,wBACgB,UAAG,UAAAA,KAAA,sDAAH,QAAhB,MAEkBY,6BAAlB,cACIZ,KAAA,cACAA,KAAA,gBAEJ,KACJ,gBAQI,OAPAA,KAAA,KAAsBgC,WAAWhC,KAAK6B,QAAhBG,YAAtB,GACAhC,KAAA,SAAsBA,KAAK6B,QAA3B,SACA7B,KAAA,SAAsBA,KAAKsC,YAAYC,gBAAgBvC,KAAjC,KAA4CA,KAAlE,UACAA,KAAA,WAAsBA,KAAKsC,YAAYE,iBAAiBxC,KAAxD,MACAA,KAAA,eAAsBA,KAAKsC,YAAYE,iBAAiBxC,KAAxD,UACAA,KAAA,uBACAA,KAAA,qBACA,KACJ,cAMI,OAJA8B,YAAW,WACP,yBACA,wBAEJ,Q,gBAIZc,SAAE,KAOE,OALK5C,KAAK6C,QAAV,KACI7C,KAAA,eAGJA,KAAA,mBACA,O,iBAEJ8C,SAAG,GAQC,OAPA,EAGW9C,KAAK6C,QAAT,KAEH7C,KAAA,eAHAA,KAAA,WAKJ,O,qBAEJ+C,SAAO,GAEH,IAAIC,EAAOC,qCAAX,GAEA,IAAK,IAAL,KAAcjD,KAAK6C,QAAnB,GACI7C,KAAA,oBAAAA,KAAA,GAGJ,aAAIkD,EACA,YAGJ,IAAK,IAAL,KAAclD,KAAK6C,QAAL,MACV7C,KAAA,uBAAAA,KAAqC,CAArC,IAEJ,c,uKAGEQ,WAAI,GAAJA,UA6BF,EA7BEA,8HA6BF,oCAAA2C,EAAA,yDAEa1C,gBAAL,oBAFR,yCAGmBT,KAAK+C,QAAQ,QAApB,2CAHZ,OAUQ,IAJIK,EAAY,IAAIxC,kBAAJ,UAAgCZ,KAAhD,MACAoD,SAAqB,IAAIxC,kBAAzBwC,qBAGIpD,KAAKqD,UAAT,OAA2B,CAavB,SATAD,iBAA2B,IAAIxC,kBAA/BwC,eACAA,6CACAA,uCACAA,wCACAA,qCACAA,6BACAA,2CAEIE,EAAJ,GACctD,KAAd,WAGQuD,EAAS,IAAI3C,kBAAJ,QAAb,SACA2C,KAAyBvD,KAAKqD,UAAUG,GAAxCD,MACAA,qBACAA,iBAAyBvD,KAAKqD,UAAUG,GAAxCD,IACAA,8BAEAA,UAAgBE,SAAhBF,GACAD,UAEJF,WAnCZ,GAsCQA,kBAA8B,CAAC,IAAIxC,YAAJ,MAAsBZ,KAArDoD,SACAA,iBAA8BpD,KAA9BoD,MACAA,oBAA8BpD,KAA9BoD,aAEIM,EAAU,IAAI9C,kBAAJ,YAAd,IAEA8C,YAAsB1D,KAAtB0D,KACAA,YAAoB1D,KAApB0D,QAEI1D,KAAKqD,UAAT,OA/CR,wBAAAF,EAAA,KAgD0BnD,KAAd,WAhDZ,kDAgDY,EAhDZ,YAiDoBA,KAAKqD,UAAUG,GAAnB,OAjDhB,wBAkDoBE,iBAAyB,CAACD,SAA1BC,IAlDpB,gFAyDkBjD,8CAAN,GAzDZ,QA0DYT,KAAA,OAAcS,kEAA8ET,KAA5F,OACAA,KAAA,cAAqBS,oCAArB,kBA3DZ,4EA6DmBT,KAAK+C,QAAZ,QAAO,OA7DnB,4DA7BEvC,uBA6BF,EA7BEA,2CAAUmD,EAAVnD,+BAAI,GAEN,EAFEA,yCAGSR,KAAK+C,QAAQ,QAApB,+BAHFvC,OAWF,SALQC,EAAgBD,KAAxB,UAAQC,YAGRkD,QAEA,EACQA,iBAAJ,KACI3D,KAAA,GAAY2D,EAAZ,IAbNnD,YAmBMC,gBAAJ,oBAnBFD,kCAoBYC,gBAAN,iBApBND,yBAsBQoD,QAAN,MAtBFpD,0DAwBE,WAAGqD,MACC7D,KAAA,sBAzBNQ,0D,0EAiGNsD,SAAI,KAOA,OALA,IACIC,EAAU/D,KAAKsC,YAAY0B,YAAYD,EAAS/D,KAAK6B,QAArDkC,WAEJ/D,KAAA,sBACAA,KAAA,mBACA,O,oBAEJiE,SAAM,GAGF,OAFAjE,KAAA,sBACAA,KAAA,6BACA,O,kBAEJkE,WAII,OAHIlE,KAAJ,QACIA,KAAA,0BAEJ,O,mBAEJmE,WAII,OAHKnE,KAAL,QACIA,KAAA,0BAEJ,O,kBAEJoE,WAII,OAHKpE,KAAL,OACIA,KAAA,2BAEJ,O,oBAEJqE,WAII,OAHIrE,KAAJ,OACIA,KAAA,2BAEJ,O,sBAGJsE,SAAQ,GAAQ,WAGRZ,EAAU,IAAI9C,kBAAJ,sBAA4C,CAAC6C,SAA3D,KACAjD,wGAA8G,WAG1G,IAAK,IAAL,KAAc,EAAd,iBAEW,eAAP,OAEIgD,GAAJ,IACI,0BAGR,OAAO,UAAP,qBACAe,YAEA,OAAO,kBAAP,Q,wBAIRC,WA8BI,OA7BAhE,+DACAR,KAAA,mBAEAA,KAAA,mBAGAA,KAAA,aACAA,KAAA,oBAGAA,KAAA,OACAA,KAAA,SACAA,KAAA,eACAA,KAAA,UACAA,KAAA,aAGAA,KAAA,cACAA,KAAA,SACAA,KAAA,UACAA,KAAA,OACAA,KAAA,sBACAA,KAAA,WACAA,KAAA,0BACAA,KAAA,WACAA,KAAA,qBAGAA,KAAA,sBACA,S,KChdFyE,EAAiB,WACnB,MAAoCC,mBAAS,IAA7C,sBAAM,EAAN,UAEA,MAAO,CACHC,eAIFlE,EAAcmE,wBAApB,GAWaC,EAAU,kBAAMC,qBAAtB,I,2CCnBMC,EDUQ,SAAC,GAAiB,IAAfC,EAAe,EAAfA,SACdC,EAAUR,IAChB,OACI,kBAAC,EAAD,UAAsBS,MAAOD,GADjC,ICVSJ,EAAUM,EAEVC,ECHb,SAAoBC,GAEhB,IAAQV,EAAeE,IAAfF,WAER,EAA0CD,mBAASC,EAAnD,8BAAM,EAAN,KAAM,EAAN,KAEA,IAAQW,YAAR,MAAM,GAAN,MAAmBC,cAAnB,MAAM,GAAN,MAAgCC,eAAhC,MAA0C,WAAQlF,wCAAlD,EAYA,OAVAmF,qBAAU,WAKN,OAJAd,kBAA2B,WACvBe,EAAiBf,EAAjBe,cAGG,WACHf,WANRc,IAWI,4BAAQD,QAAR,EAA0BG,MAA1B,EAAyCC,UAAWC,EAAqBC,UAAWC,GAChF,yBAAK7D,IAAL,IAAeyD,MAAO,CAAEK,MAAF,EAAeC,OAAQX,O,MC+C1CY,MArEf,WAEI,IAAQvB,EAAeE,IAAfF,WACR,EAA0CD,mBAASC,EAAWwB,WAA9D,mBAAOJ,EAAP,KAAsBL,EAAtB,KACA,EAA0ChB,mBAASC,EAAWyB,WAA9D,mBAAOC,EAAP,KAAsBC,EAAtB,KACA,EAA4B5B,mBAAS,gFAArC,mBAAO6B,EAAP,KAAeC,EAAf,KACMC,EAAWC,mBANN,4CAyBX,sBAAAvD,EAAA,0DACOwB,EAAWwB,UADlB,0CAGkBxB,EAAWnE,KAAK+F,EAAQ,CAC9BI,OAAa,qCACbC,MAAa,SACbC,YAAa,yCACbxD,UAAW,CAAC,CACRjB,QAAQ,EACRH,MAAQ,UACRC,IAAQ,uCACT,CACCD,MAAQ,UACRC,IAAQ,0CAbxB,OAgBU5B,QAAQwG,IAAI,WAhBtB,gDAkBYxG,QAAQwG,IAAR,MAlBZ,0DAzBW,sBAgDX,OAxCArB,qBAAU,WAYN,OAVAd,EAAW/B,GAAG,aAAa,WACvBtC,QAAQwG,IAAI,SAAUnC,EAAWwB,WACjCT,EAAiBf,EAAWwB,cAGhCxB,EAAW/B,GAAG,WAAW,WACrB0D,EAAiB3B,EAAWyB,cAIzB,WACHzB,EAAW7B,SAEhB,IA0BC,gDACqBiD,EAAe,OAAS,QACzC,6BAFJ,mBAGqBM,EAAe,OAAS,QACzC,6BACCA,GAED,8CACmB1B,EAAWoC,QAE9B,6BACI,oEACA,2BAAOC,IAAK,SAAAA,GAAG,OAAIP,EAASQ,QAAUD,GAAKE,KAAK,OAAOhC,MAAOqB,EAAQZ,MAAO,CAACK,MAAO,OAAQmB,QAAS,kBAAMV,EAASQ,QAAQG,UAAUC,SAAU,SAAAC,GAAC,OAAId,EAAUc,EAAEC,OAAOrC,WAE7K,6BACA,kBAAC,EAAD,CAAYM,QAhET,+CCyBAgC,EAtBH,WAEV,OACE,kBAAC,EAAD,KACE,iDACA,uBAAGC,KAAK,IAAR,kBACA,uBAAGA,KAAK,IAAR,OACA,uDAGA,+CACA,mDACA,+BAGA,6BACE,kBAAC,EAAD,SClBRC,IAASC,OAAO,kBAAC,EAAD,MAAStH,SAASuH,eAAe,U,kBCNjDC,EAAOC,QAAU,IAA0B,iD","file":"static/js/main.30616978.chunk.js","sourcesContent":["// Import cast framework\r\nfunction loadScript(){\r\n    return new Promise((resolve, reject) => {\r\n        window['__onGCastApiAvailable'] = resolve\r\n\r\n        if (window.chrome && !window.chrome.cast) {\r\n            var script = document.createElement('script')\r\n            script.src = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1'\r\n            script.onerror = reject\r\n            document.head.appendChild(script)\r\n        }\r\n    })\r\n}\r\n\r\n// Castjs\r\nclass Castjs {\r\n    // constructor takes optional options\r\n    constructor(opt = {}) {\r\n        \r\n        // set default receiver ID if none provided\r\n        if (!opt.receiver || opt.receiver === '') {\r\n            opt.receiver = 'CC1AD845'\r\n        }\r\n\r\n        // private variables\r\n        this._events     = {}\r\n        this._player     = null\r\n        this._controller = null\r\n        this._mediaSession = null\r\n\r\n        // public variables\r\n        this.version        = 'v4.1.2'\r\n        this.receiver       = opt.receiver\r\n        this.joinpolicy     = opt.joinpolicy\r\n        this.available      = false\r\n        this.connected      = false\r\n        this.device         = 'Chromecast'\r\n        this.src            = ''\r\n        this.title          = ''\r\n        this.description    = ''\r\n        this.poster         = ''\r\n        this.subtitles      = []\r\n        this.volumeLevel    = 1\r\n        this.muted          = false\r\n        this.paused         = false\r\n        this.time           = 0\r\n        this.timePretty     = '00:00:00'\r\n        this.duration       = 0\r\n        this.durationPretty = '00:00:00'\r\n        this.progress       = 0\r\n        this.state          = 'disconnected'\r\n\r\n        // initialize chromecast framework\r\n        this._init()\r\n    }\r\n    \r\n    async _init() {\r\n        // casting only works on chrome, opera, brave and vivaldi\r\n        if (!window.chrome || !window.chrome.cast || !window.chrome.cast.isAvailable) {\r\n            \r\n            try {\r\n                await loadScript()\r\n            } catch (error) {\r\n                this.trigger('error', error)\r\n                console.error(error)\r\n                throw new Error(\"Error loading Cast API\")\r\n            }\r\n        }\r\n\r\n        const { CastContext = null, RemotePlayer, RemotePlayerController, CastState, CastContextEventType } = cast.framework\r\n\r\n        // valid join policies\r\n        const joinpolicies = [\r\n            chrome.cast.AutoJoinPolicy.TAB_AND_ORIGIN_SCOPED,\r\n            chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,\r\n            chrome.cast.AutoJoinPolicy.PAGE_SCOPED\r\n        ]\r\n\r\n        // only allow valid join policy\r\n        if (!this.joinpolicies || joinpolicies.indexOf(this.joinpolicy) === -1) {\r\n            this.joinpolicy = chrome.cast.AutoJoinPolicy.TAB_AND_ORIGIN_SCOPED\r\n        }\r\n\r\n\r\n        // initialize cast API\r\n        CastContext.getInstance().setOptions({\r\n            receiverApplicationId:      this.receiver,\r\n            autoJoinPolicy:             this.joinpolicy,\r\n            language:                   'en-US',\r\n            resumeSavedSession:         false,\r\n        })\r\n        // create remote player controller\r\n        this._player = new RemotePlayer()\r\n        this._controller = new RemotePlayerController(this._player)\r\n\r\n        // register callback events\r\n        this._controller.addEventListener('isConnectedChanged',  this._isConnectedChanged.bind(this))\r\n        this._controller.addEventListener('isMediaLoadedChanged',this._isMediaLoadedChanged.bind(this))\r\n        this._controller.addEventListener('isMutedChanged',      this._isMutedChanged.bind(this))\r\n        this._controller.addEventListener('isPausedChanged',     this._isPausedChanged.bind(this))\r\n        this._controller.addEventListener('currentTimeChanged',  this._currentTimeChanged.bind(this))\r\n        this._controller.addEventListener('durationChanged',     this._durationChanged.bind(this))\r\n        this._controller.addEventListener('volumeLevelChanged',  this._volumeLevelChanged.bind(this))\r\n        this._controller.addEventListener('playerStateChanged',  this._playerStateChanged.bind(this))\r\n\r\n        CastContext.getInstance().addEventListener(CastContextEventType.CAST_STATE_CHANGED, this._isAvailableChanged.bind(this))\r\n        this.available = CastContext.getInstance().getCastState() !== CastState.NO_DEVICES_AVAILABLE\r\n        this.trigger('available')\r\n    }\r\n\r\n    _isAvailableChanged(e) {\r\n        const { CastContext, CastState } = cast.framework \r\n        this.available = CastContext.getInstance().getCastState() !== CastState.NO_DEVICES_AVAILABLE\r\n        this.trigger('available')\r\n    }\r\n\r\n    _isMediaLoadedChanged() {\r\n        // don't update media info if not available\r\n        if (!this._player.isMediaLoaded) {\r\n            return\r\n        }\r\n        // there is a bug where mediaInfo is not directly available\r\n        // so we are skipping one tick in the event loop, zzzzzzzzz\r\n        setTimeout(() => {\r\n            if (!this._player.mediaInfo) {\r\n                return\r\n            }\r\n            // Update device name\r\n            this.device = cast.framework.CastContext.getInstance().getCurrentSession().getCastDevice().friendlyName || this.device\r\n\r\n            // Update media variables\r\n            this.src                = this._player.mediaInfo.contentId\r\n            this.title              = this._player.title || null\r\n            this.description        = this._player.mediaInfo.metadata.subtitle || null\r\n            this.poster             = this._player.imageUrl || null\r\n            this.subtitles          = []\r\n            this.volumeLevel        = this.volumeLevel = Number((this._player.volumeLevel).toFixed(1))\r\n            this.muted              = this._player.isMuted\r\n            this.paused             = this._player.isPaused\r\n            this.time               = Math.round(this._player.currentTime, 1)\r\n            this.timePretty         = this._controller.getFormattedTime(this.time)\r\n            this.duration           = this._player.duration\r\n            this.durationPretty     = this._controller.getFormattedTime(this._player.duration)\r\n            this.progress           = this._controller.getSeekPosition(this.time, this._player.duration)\r\n            this.state              = this._player.playerState.toLowerCase()\r\n\r\n            // Loop over the subtitle tracks\r\n            for (var i in this._player.mediaInfo.tracks) {\r\n                // Check for subtitle\r\n                if (this._player.mediaInfo.tracks[i].type === 'TEXT') {\r\n                    // Push to media subtitles array\r\n                    this.subtitles.push({\r\n                        label: this._player.mediaInfo.tracks[i].name,\r\n                        src:   this._player.mediaInfo.tracks[i].trackContentId\r\n                    })\r\n                }\r\n            }\r\n            // Get the active subtitle\r\n            var active = cast.framework.CastContext.getInstance().getCurrentSession().getSessionObj().media[0].activeTrackIds\r\n            if (active && active.length && this.subtitles[active[0]]) {\r\n                this.subtitles[active[0]].active = true\r\n            }\r\n        })\r\n\r\n    }\r\n    // Player controller events\r\n    _isConnectedChanged() {\r\n        this.connected = this._player.isConnected\r\n        if (this.connected) {\r\n            this.device = cast.framework.CastContext.getInstance().getCurrentSession().getCastDevice().friendlyName || this.device\r\n        }\r\n        this.state = !this.connected ? 'disconnected' : 'connected'\r\n        this.trigger('statechange')\r\n        this.trigger(!this.connected ? 'disconnect' : 'connect')\r\n    }\r\n    _currentTimeChanged() {\r\n        var past            = this.time\r\n        this.time           = Math.round(this._player.currentTime, 1)\r\n        this.duration       = this._player.duration\r\n        this.progress       = this._controller.getSeekPosition(this.time, this.duration)\r\n        this.timePretty     = this._controller.getFormattedTime(this.time)\r\n        this.durationPretty = this._controller.getFormattedTime(this.duration)\r\n        // Only trigger timeupdate if there is a difference\r\n        if (past != this.time && !this._player.isPaused) {\r\n            this.trigger('timeupdate')\r\n        }\r\n    }\r\n    _durationChanged() {\r\n        this.duration = this._player.duration\r\n    }\r\n    _volumeLevelChanged() {\r\n        this.volumeLevel = Number((this._player.volumeLevel).toFixed(1))\r\n        if (this._player.isMediaLoaded) {\r\n            this.trigger('volumechange')\r\n        }\r\n    }\r\n    _isMutedChanged() {\r\n        var old = this.muted\r\n        this.muted = this._player.isMuted\r\n        if (old != this.muted) {\r\n            this.trigger(this.muted ? 'mute' : 'unmute')\r\n        }\r\n    }\r\n    _isPausedChanged() {\r\n        this.paused = this._player.isPaused\r\n        if (this.paused) {\r\n            this.trigger('pause')\r\n        }\r\n    }\r\n    _playerStateChanged() {\r\n        this.connected = this._player.isConnected\r\n        if (!this.connected) {\r\n            return\r\n        }\r\n        this.device = cast.framework.CastContext.getInstance().getCurrentSession().getCastDevice().friendlyName || this.device\r\n        this.state = this._player.playerState.toLowerCase()\r\n        switch(this.state) {\r\n            case 'idle':\r\n                this.trigger('statechange')\r\n                const idleReason = this._mediaSession?.idleReason ?? \"\"\r\n                // don't trigger end if cast was interrupted. new media was loaded\r\n                if(idleReason !== chrome.cast.media.IdleReason.INTERRUPTED){\r\n                    this.state = 'ended'\r\n                    this.trigger('end')\r\n                }\r\n                return this\r\n            case 'buffering':\r\n                this.time           = Math.round(this._player.currentTime, 1)\r\n                this.duration       = this._player.duration\r\n                this.progress       = this._controller.getSeekPosition(this.time, this.duration)\r\n                this.timePretty     = this._controller.getFormattedTime(this.time)\r\n                this.durationPretty = this._controller.getFormattedTime(this.duration)\r\n                this.trigger('statechange')\r\n                this.trigger('buffering')\r\n                return this\r\n            case 'playing':\r\n                // we have to skip a tick to give mediaInfo some time to update\r\n                setTimeout(() => {\r\n                    this.trigger('statechange')\r\n                    this.trigger('playing')\r\n                })\r\n                return this\r\n        }\r\n    }\r\n    // Class functions\r\n    on(event, cb) {\r\n        // If event is not registered, create array to store callbacks\r\n        if (!this._events[event]) {\r\n            this._events[event] = []\r\n        }\r\n        // Push callback into event array\r\n        this._events[event].push(cb)\r\n        return this\r\n    }\r\n    off(event) {\r\n        if (!event) {\r\n            // if no event name was given, reset all events\r\n            this._events = {}\r\n        } else if (this._events[event]) {\r\n            // remove all callbacks from event\r\n            this._events[event] = []\r\n        }\r\n        return this\r\n    }\r\n    trigger(event) {\r\n        // Slice arguments into array\r\n        var tail = Array.prototype.slice.call(arguments, 1)\r\n        // If event exist, call callback with callback data\r\n        for (var i in this._events[event]) {\r\n            this._events[event][i].apply(this, tail)\r\n        }\r\n        // dont call global event if error\r\n        if (event === 'error') {\r\n            return this\r\n        }\r\n        // call global event handler if exist\r\n        for (var i in this._events['event']) {\r\n            this._events['event'][i].apply(this, [event])\r\n        }\r\n        return this\r\n    }\r\n\r\n    async cast(src, metadata = {}) {\r\n        // We need a source! Don't forget to enable CORS\r\n        if (!src) {\r\n            return this.trigger('error', 'No media source specified.')\r\n        }\r\n\r\n        const { CastContext } = cast.framework\r\n\r\n\r\n        metadata.src = src\r\n        // Update media variables with user input\r\n        for (var key in metadata) {\r\n            if (metadata.hasOwnProperty(key)) {\r\n                this[key] = metadata[key]\r\n            }\r\n        }\r\n\r\n        \r\n        try {\r\n            if(!CastContext.getInstance().getCurrentSession()){\r\n                await CastContext.getInstance().requestSession()\r\n            }\r\n            await _load.apply(this)\r\n        } catch (error) {\r\n            if(error !== 'cancel'){\r\n                this.trigger('error', error)\r\n            }\r\n        }\r\n\r\n        async function _load(){\r\n            {\r\n                if (!CastContext.getInstance().getCurrentSession()) {\r\n                    return this.trigger('error', 'Could not connect with the cast device')\r\n                }\r\n                // Create media cast object\r\n                var mediaInfo = new chrome.cast.media.MediaInfo(this.src)\r\n                mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata()\r\n    \r\n                // This part is the reason why people love this library <3\r\n                if (this.subtitles.length) {\r\n                    // I'm using the Netflix subtitle styling\r\n                    // chrome.cast.media.TextTrackFontGenericFamily.CASUAL\r\n                    // chrome.cast.media.TextTrackEdgeType.DROP_SHADOW\r\n                    mediaInfo.textTrackStyle = new chrome.cast.media.TextTrackStyle()\r\n                    mediaInfo.textTrackStyle.backgroundColor = '#00000000'\r\n                    mediaInfo.textTrackStyle.edgeColor       = '#00000016'\r\n                    mediaInfo.textTrackStyle.edgeType        = 'DROP_SHADOW'\r\n                    mediaInfo.textTrackStyle.fontFamily      = 'CASUAL'\r\n                    mediaInfo.textTrackStyle.fontScale       = 1.0\r\n                    mediaInfo.textTrackStyle.foregroundColor = '#FFFFFF'\r\n    \r\n                    var tracks = []\r\n                    for (var i in this.subtitles) {\r\n                        // chrome.cast.media.TrackType.TEXT\r\n                        // chrome.cast.media.TextTrackType.CAPTIONS\r\n                        var track =  new chrome.cast.media.Track(i, 'TEXT')\r\n                        track.name =             this.subtitles[i].label\r\n                        track.subtype =          'CAPTIONS'\r\n                        track.trackContentId =   this.subtitles[i].src\r\n                        track.trackContentType = 'text/vtt'\r\n                        // This bug made me question life for a while\r\n                        track.trackId = parseInt(i)\r\n                        tracks.push(track)\r\n                    }\r\n                    mediaInfo.tracks = tracks\r\n                }\r\n                // Let's prepare the metadata\r\n                mediaInfo.metadata.images =   [new chrome.cast.Image(this.poster)]\r\n                mediaInfo.metadata.title =    this.title\r\n                mediaInfo.metadata.subtitle = this.description\r\n                // Prepare the actual request\r\n                var request = new chrome.cast.media.LoadRequest(mediaInfo)\r\n                // Didn't really test this currenttime thingy, dont forget\r\n                request.currentTime = this.time\r\n                request.autoplay = !this.paused\r\n                // If multiple subtitles, use the active: true one\r\n                if (this.subtitles.length) {\r\n                    for (var i in this.subtitles) {\r\n                        if (this.subtitles[i].active) {\r\n                            request.activeTrackIds = [parseInt(i)]\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n\r\n                try {\r\n                    await CastContext.getInstance().getCurrentSession().loadMedia(request)    \r\n                    this.device = CastContext.getInstance().getCurrentSession().getCastDevice().friendlyName || this.device\r\n                    this._mediaSession = CastContext.getInstance().getCurrentSession().getMediaSession()\r\n                } catch (error) {\r\n                    return this.trigger('error', error)\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    seek(seconds, isPercentage) {\r\n        // if seek(15, true) we assume 15 is percentage instead of seconds\r\n        if (isPercentage) {\r\n            seconds = this._controller.getSeekTime(seconds, this._player.duration)\r\n        }\r\n        this._player.currentTime = seconds\r\n        this._controller.seek()\r\n        return this\r\n    }\r\n    volume(float) {\r\n        this._player.volumeLevel = float\r\n        this._controller.setVolumeLevel()\r\n        return this\r\n    }\r\n    play() {\r\n        if (this.paused) {\r\n            this._controller.playOrPause()\r\n        }\r\n        return this\r\n    }\r\n    pause() {\r\n        if (!this.paused) {\r\n            this._controller.playOrPause()\r\n        }\r\n        return this\r\n    }\r\n    mute() {\r\n        if (!this.muted) {\r\n            this._controller.muteOrUnmute()\r\n        }\r\n        return this\r\n    }\r\n    unmute() {\r\n        if (this.muted) {\r\n            this._controller.muteOrUnmute()\r\n        }\r\n        return this\r\n    }\r\n    // subtitle allows you to change active subtitles while casting\r\n    subtitle(index) {\r\n        // this is my favorite part of castjs\r\n        // prepare request to edit the tracks on current session\r\n        var request = new chrome.cast.media.EditTracksInfoRequest([parseInt(index)])\r\n        cast.framework.CastContext.getInstance().getCurrentSession().getSessionObj().media[0].editTracksInfo(request, () => {\r\n            // after updating the device we should update locally\r\n            // loop trough subtitles\r\n            for (var i in this.subtitles) {\r\n                // remove active key from all subtitles\r\n                delete this.subtitles[i].active\r\n                // if subtitle matches given index, we set to true\r\n                if (i == index) {\r\n                    this.subtitles[i].active = true\r\n                }\r\n            }\r\n            return this.trigger('subtitlechange')\r\n        }, (err) => {\r\n            // catch any error\r\n            return this.trigger('error', err)\r\n        })\r\n    }\r\n    // disconnect will end the current session\r\n    disconnect() {\r\n        cast.framework.CastContext.getInstance().endCurrentSession(true)\r\n        this._controller.stop()\r\n\r\n        this._mediaSession = null\r\n\r\n        // application variables\r\n        this.connected  = false\r\n        this.device     = 'Chromecast'\r\n\r\n        // media variables\r\n        this.src         = ''\r\n        this.title       = ''\r\n        this.description = ''\r\n        this.poster      = ''\r\n        this.subtitles   = []\r\n\r\n        // player variable\r\n        this.volumeLevel    = 1\r\n        this.muted          = false\r\n        this.paused         = false\r\n        this.time           = 0\r\n        this.timePretty     = '00:00:00'\r\n        this.duration       = 0\r\n        this.durationPretty = '00:00:00'\r\n        this.progress       = 0\r\n        this.state          = 'disconnected'\r\n\r\n\r\n        this.trigger('disconnect')\r\n        return this\r\n    }\r\n}\r\n\r\nconst Cast = Castjs\r\nexport default Cast","import React from \"react\"\r\nimport { createContext, useContext, useEffect, useState } from 'react'\r\nimport Cast from \"../Cast\"\r\n\r\n\r\n\r\nconst useProvideCast = () => {\r\n    const [chromecast, setChromecast] = useState(new Cast())\r\n\r\n    return {\r\n        chromecast,\r\n    }\r\n}\r\n\r\nconst CastContext = createContext(useProvideCast)\r\n\r\nconst CastProvider = ({ children }) => {\r\n    const context = useProvideCast()\r\n    return (\r\n        <CastContext.Provider value={context}>\r\n            {children}\r\n        </CastContext.Provider>\r\n    )\r\n}\r\n\r\nexport const useCast = () => useContext(CastContext)\r\n\r\nexport default CastProvider","import React from 'react'\nimport {default as Provider, useCast as _useCast} from './CastProvider'\n\n\nimport { default as Button } from './CastButton'\n\nexport const CastProvider = Provider\n\nexport const useCast = _useCast\n\nexport const CastButton = Button","import React, { useEffect, useState } from \"react\"\r\nimport { useCast } from \"../CastProvider\"\r\n\r\nimport { default as ico } from 'chromecast.svg'\r\n\r\nimport _styles from './styles.module.css'\r\n\r\nfunction CastButton(props){\r\n\r\n    const { chromecast } = useCast()\r\n\r\n    const [castAvailable, setCastAvailable] = useState(chromecast.available)\r\n\r\n    const { size = 20, styles = {}, onClick = () => { console.error(\"No handler available.\") } } = props\r\n\r\n    useEffect(() => {\r\n        chromecast.on('available', () => {\r\n            setCastAvailable(chromecast.available)\r\n        })\r\n\r\n        return function cleanup(){\r\n            chromecast.off()\r\n        }\r\n    }, [])\r\n\r\n    return (\r\n        <button onClick={onClick} style={styles} className={_styles.cast_button} disabled={!castAvailable}>\r\n            <img src={ico} style={{ width: size, height: size }} />\r\n        </button>\r\n    )\r\n}\r\n\r\nexport default CastButton","import React, { useEffect, useRef, useState } from 'react'\r\nimport { ExampleComponent, CastProvider, useCast, CastButton } from 'react-castjs'\r\n\r\n\r\n\r\nfunction Test(){\r\n\r\n    const { chromecast } = useCast()\r\n    const [castAvailable, setCastAvailable] = useState(chromecast.available)\r\n    const [castConnected, setCastConnected] = useState(chromecast.connected)\r\n    const [source, setSource] = useState('https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/Sintel.mp4')\r\n    const inputRef = useRef()\r\n\r\n    useEffect(() => {\r\n\r\n        chromecast.on('available', () => {\r\n            console.log('change', chromecast.available)\r\n            setCastAvailable(chromecast.available)\r\n        })\r\n\r\n        chromecast.on('connect', () => {\r\n            setCastConnected(chromecast.connected)\r\n        })\r\n\r\n\r\n        return function cleanup(){\r\n            chromecast.off()\r\n        }\r\n    }, [])\r\n\r\n    async function cast(){\r\n        if(chromecast.available){\r\n            try {\r\n                await chromecast.cast(source, {\r\n                poster     : 'https://castjs.io/media/poster.jpg',\r\n                title      : 'Sintel',\r\n                description: 'Third Open Movie by Blender Foundation',\r\n                subtitles: [{\r\n                    active: true,\r\n                    label : 'English',\r\n                    src   : 'https://castjs.io/media/english.vtt'\r\n                }, {\r\n                    label : 'Spanish',\r\n                    src   : 'https://castjs.io/media/spanish.vtt'\r\n                }],\r\n              })\r\n              console.log(\"casting\")\r\n            } catch (error) {\r\n                console.log(error)\r\n            }\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            cast available: {castAvailable? \"true\" : \"false\"}\r\n            <br/>\r\n            cast connected: {castConnected? \"true\" : \"false\"}\r\n            <br/>\r\n            {castConnected\r\n            &&\r\n            <div>\r\n                connected to: {chromecast.device}\r\n            </div>}\r\n            <div>\r\n                <label>paste source url (video or audio)</label>\r\n                <input ref={ref => inputRef.current = ref} type=\"text\" value={source} style={{width: \"80%\"}} onFocus={() => inputRef.current.select()} onChange={e => setSource(e.target.value)}/> \r\n            </div>\r\n            <br/>\r\n            <CastButton onClick={cast}/>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Test","import React, { useEffect } from 'react'\n\nimport { ExampleComponent, CastProvider } from 'react-castjs'\nimport 'react-castjs/dist/index.css'\nimport Test from './Test'\n\n\n\nconst App = () => {\n\n  return (\n    <CastProvider>\n      <h1>react-castjs demo</h1>\n      <a href=\"\">view on github</a>\n      <a href=\"\">npm</a>\n      <code>\n        npm i react-castjs -S\n      </code>\n      <h2>Getting started</h2>\n      <h3>Wrap your React-App</h3>\n      <code>\n        \n      </code>\n      <div>\n        <Test />\n      </div>\n    </CastProvider>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n","module.exports = __webpack_public_path__ + \"static/media/chromecast~bhycLeeK.4a5ab6bd.svg\";"],"sourceRoot":""}